---
layout:     post
title:      从WE到BERT
subtitle:   自然语言预训练：从Word Embedding到蒂花之秀BERT
date:       2019-12-23
author:     MeteorMan
header-img: img/post-bg-keybord.jpg
catalog: true
tags:
    - Natural Language Processing
    - Word Embedding
    - BERT


---

>本文将针对自然语言处理的语言模型预训练领域进行梳理，并介绍其各自优缺点。

# 前言

​		最近自然语言处理领域的预训练风头正盛，无集群、无TPU的我们只能看着大佬们各自秀出自己的trick（MeteorMan就是如此眼巴巴的看着）。而所有的预训练模型基于都可归为BERT模型的推动，由此可见BERT的重要性。由于模型太多，近段时间也一直忙于工作和答辩，并未好好梳理现阶段的潮流模型，因此在这里针对相关模型（从WE到BERT）进行详细介绍和总结。

# Word Embedding

​		说到NLP的预训练，那么肯定要从WE (Word Embedding)讲起了，网上关于WE的介绍很多很多，MeteorMan在这里将会粗略的讲解其中的模型精髓。在说Word Embedding之前，先介绍一下语言模型，因为从Word2vec到BERT所要解决的目标都是语言模型的建模。

​		那么什么是语言模型呢？维基百科上是这样解释的：“统计语言模型是一个单词序列上的概率分布，对于一个给定长度为m的序列，它可以为整个序列产生一个概率 P(w_1,w_2,…,w_m) 。”其实就是想办法找到一个概率分布，它可以表示任意一个句子或序列出现的概率。

给出以下三个句子：

- 我昨天和父母去公园玩

- 我和父母去公园玩昨天

- 我昨天和去公园父母玩		

  
  $$
  P(w_{1},w_{2},w_{3},...,w_{n})=P(w_{1})P(w_{2}|w_{1})P(w_{3}|w_{1},w_{2})\cdot \cdot \cdot P(w_{n}|w_{1},w_{2},w_{n-1})
  $$
  

​        为了能够量化地衡量上面三个句子中哪一个句子更符合平常的表达方式（人话），可以设计上面所示函数，核心思想是根据句子中一系列的上文单词来预测下文属于某一个单词的概率大小。通过这种计算方式，句子中的每个单词都是根据上文来预测自己，然后将每一个单词的产生概率相乘得到的数值就代表这句话的量化值，量化值越大，这句话就越合理（像人话。。。）。

​		为了解决上述语言模型建模的问题，Bengio于2003年提出了[NNLM](http://jmlr.org/papers/volume3/bengio03a/bengio03a.pdf)（神经网络语言模型），如下图所示。



![神经网络语言模型架构图](https://i.loli.net/2019/12/13/cRCixD7wfegI8W4.png)

​		现在讲一讲NNLM的训练过程：训练目标就是是输入句中某个单词Wt的前t-1个单词，要求网络能够正确预测目标单词Wt，即最大化概率值：
$$
P(w_{t}|w_{1},w_{2},...,w_{t-1})
$$
​		前面任意单词Wi用Onehot编码后的序列作为原始的单词对应输入，然后乘以一个<u>**矩阵Q**</u>获得单词向量C(Wi)，继而将每个单词向量拼接后输入到隐藏层，最后接softmax来预测目标单词。那么有人会问了，这里面说的C(Wi)是什么啊？其实这个就是单词对应的Word Embedding，来自于<u>**矩阵Q**</u>（包含L行，L代表词典大小，而每一行都代表单词对应的Word Embedding值）。而这个矩阵Q其实就是网络的参数矩阵，需要学习获得，训练开始时随机初始化Q的值，当这个网络训练好之后，矩阵Q的内容被正确赋值，每一行代表一个单词对应的Word embedding值。通过这个NNLM网络学习语言模型任务，这个网络不仅自己能够根据上文预测后接单词是什么，同时获得一个**副产品**，就是矩阵Q，这就是单词的Word Embedding是被如何学会的。

​		在WordEmbedding出现之后，作者紧接着开源了相关工具Word2Vec，这个工具是在2013年使用最火的用于语言模型训练Word Embedding的工具。那么Word2Vec背后的工作原理是什么呢？

![CBOW模型](https://i.loli.net/2019/12/23/xFR8yotprm2VcZq.png)

​                                                                       CBOW模型图

![Skip-Gram模型图](https://i.loli.net/2019/12/23/5UDBwygLQKd9txY.png)

​                                                                   Skip-Gram模型图

​		如上面两个图所示，Word2Vec基于两种模型去训练：CBOW（Continuous Bag-of-Words Model）和Skip-Gram（Continuous Skip-gram Model）。其中，CBOW的核心思想是选定句中的一个目标词，然后根据这个目标词的上文和下文来预测这个目标词；而Skip-gram与CBOW输入上下文词相反，它是输入一个中心词，然后让网络模型与预测这个中心词的上下文词。谈到这里，或许读者会察觉到Word2Vec的工作模式与NNLM很类似，但是NNLM是输入一个词语的上文，然后让模型去预测这个词。这种模式与Word2Vec是有显著差异的。Word2Vec采用这种工作模式是因为NNLM的主要任务是学习一个解决语言模型任务的网络结构，语言模型就是要看到上文预测下文，而Word embedding只是这个语言模型的副产品（权重参数矩阵）。但是Word2Vec目标不一样，它就是用来做word embedding的，word embedding就是它的主产品，因此它完全可以随性地这么去训练网络。

​		既然本文讲的知识涉及到了BERT，那么上述所介绍的CBOW训练方式其实是与它有些关系的，后面会进行详细介绍。

​		下面，MeteorMan通过sklearn的word2vec来训练语料，并生成一些相似词语。

![](https://pic3.zhimg.com/80/v2-ffc7595cf4d9548d59a7fd90241f151e_hd.jpg)

​		于Word2Vec之后又出现了Glove，使用Word2Vec或者Glove，通过做语言模型任务，就可以获得每个单词的Word Embedding，那么这种方法的效果如何呢？上面给了自己训练的几个例子，可以看出有些例子效果还是很不错的，一个单词表达成Word Embedding后，很容易找出语义相近的其它词汇。

​		那么预训练是什么呢？其实上述介绍的Word Embedding做法就是标准的预训练过程。要理解这一点要看看学会Word Embedding后下游任务是怎么用它的。

![WE下游任务](https://i.loli.net/2019/12/21/Vwvi8shdnFp1yYG.png)

​		假设如上图所示，我们有个NLP的下游任务，比如QA，就是问答问题，所谓问答问题，指的是给定一个问题X，给定另外一个句子Y,要判断句子Y是否是问题X的正确答案。问答问题假设设计的网络结构如上图所示，这里不展开讲了，懂得自然懂，不懂的也没关系，因为这点对于本文主旨来说不关键，关键是网络如何使用训练好的Word Embedding的。它的使用方法其实和前面讲的NNLM是一样的，句子中每个单词以Onehot形式作为输入，然后乘以学好的Word Embedding矩阵Q，就直接取出单词对应的Word Embedding了。这乍看上去好像是个查表操作，不像是预训练的做法是吧？其实不然，那个Word Embedding矩阵Q其实就是网络Onehot层到embedding层映射的网络参数矩阵。所以你看到了，使用Word Embedding等价于什么？等价于把Onehot层到embedding层的网络用预训练好的参数矩阵Q初始化了。这跟图像领域的低层预训练过程其实是一样的，区别无非Word Embedding只能初始化第一层网络参数，再高层的参数就无能为力了。下游NLP任务在使用Word Embedding的时候也类似图像有两种做法，一种是Frozen，就是Word Embedding那层网络参数固定不动；另外一种是Fine-Tuning，就是Word Embedding这层参数使用新的训练集合训练也需要跟着训练过程更新掉。

![多义词](https://i.loli.net/2019/12/21/wm1EbjeQJYUOzpK.png)

​		上面所示的做法就是18年以前NLP领域使用预训练的典型做法，那么为什么现今BERT会如此的受欢迎而不是WE呢？肯定是WE这种方式存在致命缺陷呀。而这个致命缺陷就是多义词问题。而多义词问题是NLP中经常出现的现象，也是预研灵活性和高效性的一种体现。那么多义词对于Word Embedding会有什么负面影响呢？如上图所示，词语Bank有两个含义，但是Word Embedding 对Bank这个单词进行编码时，不能区分开这两个不同的含义，因为尽管Bank在不同句中的上下文单词不同，但是再用语言模型训练时，不论什么上下文的句子经过word2vec，都是预测相同的单词Bank，而同一个单词对应的是矩阵中的同一行参数空间，这导致两种不同的上下文信息都会编码到相同的word embedding空间里面去，也因此导致word embedding无法区分多义词的不同语义。

​		为了解决这个多义词问题，ELMO横空出世，提供了一种简洁优雅的解决方案。

# ELMO

​		ELMO是“Embedding from Language Models”的简称，ELMO的论文题目“Deep contextualized word representation”更能体现出这个模型的精髓所在。而其精髓主要体现在两个方面，一个方面是deep，一个方面是context，其中context更为关键。18年之前的word embedding是个**静态**的训练方式，所谓“静态”是指训练好之后的每个单词的表达已经被固定住，在接入下游任务时，不论这个单词的上下文是什么，它的word embedding是一成不变的，不会随着上下文场景的变化而进行变化。上面所示的Bank多义词的例子就很好的说明了这一点。而ELMO采取的是动态调整的思路，它的本质思想是：事先使用语言模型生成每个单词对应的word embedding，此时多义词仍然无法区分（每个单词已经具备特定的上下文），但是在接入下游任务时，让模型根据上下文单词的语义去调整单词的word embedding，这样经过调整后的word embedding更能表达在指定上下文环境中的具体含义，多义词问题也因此解决。所以我们可以认为ELMO本身是个根据当前上下文来对某个单词的word embedding进行动态调整的思路。

![ELMO模型架构](https://i.loli.net/2019/12/21/wukhyGfHNjApTEo.png)

​		具体而言，ELMO也采用了典型的两阶段过程，第一个阶段是语言模型预训练，第二个阶段是接入下游任务时，从预训练网络中提取对应单词的网络各层的word embedding作为新特征补充到下游任务中。上图展示的是预训练过程，其网络结构为双层双向LSTM，目前语言模型训练的任务目标是根据单词Wi的上下文去正确预测单词Wi，Wi之前的单词序列Context-before称为上文，之后的单词序列Context-after称为下文。途中左端的前向双层LSTM代表正方向编码器，输入的是从左到右顺序的除了预测单词Wi外的上文Context-before；右端的逆向双层LSTM代表反方向编码器，输入的是从右到左的逆序的句子下文Context-after；每个编码器的深度都是两层LSTM叠加。这种网络结构在NLP领域其实很常见，使用这种网络结构利用大量语料做语言模型任务就能预先训练好这个网络。在训练好这个网络之后，输入一个新句子Snew，句子中的每个单词都能得到对应的三个Embedding：最底层是单词的Word Embedding，往上走是第一层双向LSTM中对应单词位置的Embedding，这层编码单词的句法信息多一些；在往上走是第二层LSTM对应单词位置的Embedding，这层编码单词的语义信息更多一些。也就是说，ELMO的预训练过程不仅仅学会单词的Word Embedding。还学会了一个双层双向的LSTM网络结构，而这两者后面都有用。

![ELMO下游任务](https://i.loli.net/2019/12/21/pTldjiz2A6eRN7U.png)

​		上面介绍的是ELMO的第一阶段：预训练阶段。在预训练好网络结构后，如何给下游任务使用呢？比如我们的下游任务仍然是QA问题，此时对于问句X，我们可以先将句子X作为预训练好的ELMO网络的输入，这样句子X中每个单词在ELMO网络中都能获得对应的三个embedding，之后分别给予这三个embedding一个权重，这个权重可以通过学习得来，根据各自权重累加求和，将三个embedding整合成一个。然后将整合后的这个embedding作为句子X在网络中对应单词的输入，以此作为补充的新特征给下游任务使用。对于上图所示下游任务QA中的回答句子Y来说也是如此处理。因为ELMO给下游提供的是每个单词的特征形式，所以这一类预训练的方法被称为“Feature-based Pre-Training”。至于为何这么做能够达到区分多义词的效果，你可以想一想，其实比较容易想明白原因。

![ELMO在多义词上的表现](https://i.loli.net/2019/12/23/WQ6IMr2V1SYDEeZ.png)

​		那么ELMO针对多义词问题具体表现效果如何呢？上图给了个例子，对于Glove训练出的Word Embedding来说，多义词比如play，根据它的embedding找出的最接近的其它单词大多数集中在体育领域，这很明显是因为训练数据中包含play的句子中体育领域的数量明显占优导致；而使用ELMO，根据上下文动态调整后的embedding不仅能够找出对应的“演出”的相同语义的句子，而且还可以保证找出的句子中的play对应的词性也是相同的，这是超出期待之处。之所以会这样，是因为我们上面提到过，第一层LSTM编码了很多句法信息，这在这里起到了重要作用。

![ELMO在NLP任务中的性能表现](https://i.loli.net/2019/12/23/GNUVTvd4BPpzlhi.png)

​		ELMO在NLP任务中的表现又怎么样呢？实验效果见上图，6个NLP任务中性能都有幅度不同的提升，最高的提升达到25%左右，而且这6个任务的覆盖范围比较广，包含句子语义关系判断，分类任务，阅读理解等多个领域，这说明其适用范围是非常广的，普适性强，这是一个非常好的优点。

​		然而在GPT和BERT出来的情况下，再次回看ELMO，我们会发现它存在两个明显缺点：1.LSTM抽取特征能力远远弱于Transformer；2.拼接方式双向融合特征能力偏弱。

​		我们如果把ELMO这种预训练方法和图像领域的预训练方法对比，发现两者模式看上去还是有很大差异的。除了以ELMO为代表的这种基于特征融合的预训练方法外，NLP里还有一种典型做法，这种做法和图像领域的方式就是看上去一致的了，一般将这种方法称为“基于Fine-tuning的模式”，而GPT就是这一模式的典型开创者。

# GPT

![GPT架构图](https://i.loli.net/2019/12/23/oI59mYliXTMA8OP.png)

​		GPT是“Generative Pre-Training”的简称，从名字看其含义是指的生成式的预训练。GPT同样采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二个阶段通过Fine-tuning的模式解决下游任务。上图展示了GPT的预训练过程，其实和ELMO是类似的，主要不同在于两点：首先，特征抽取器不是用的RNN，而是用的Transformer，上面提到过Transformer的特征抽取能力强于RNN，这个选择很明显是非常明智的；其次，GPT的预训练虽然仍然是以语言模型作为目标任务，但是采用的是单向的语言模型，所谓“单向”的含义是指：语言模型训练的任务目标是根据单词Wi的上下文去正确预测单词Wi，Wi之前的单词序列Context-before被称为上文，之后的单词序列Context-after被称为下文。ELMO在做语言模型预训练的时候，预测单词Wi同时使用了上文和下文，而GPT只采用了Context-before这个上文来进行预测，抛弃了Context-after下文。这个选择在现在看来并不是个很好的选择，原因很简单，它没有把单词的下文融合起来，这限制了其在更多应用场景的效果，比如阅读理解这种任务，在做任务的时候是可以允许同时看到上文和下文一起做决策的。如果预训练时候不把单词的下文嵌入到Word Embedding中，是很吃亏的，白白丢掉了很多信息。

​		这里先简单介绍下Transformer。首先，Transformer是个叠加的“自注意力机制（Self Attention）”构成的深度网络，是目前NLP里最强的特征抽取器，注意力这个机制在此被发扬光大，从人物的配角不断抢戏，直到Transformer一跃踢开RNN和CNN这两个传统特征抽取器，荣升头牌，大红大紫。关于注意力机制的定义可以参考[这篇文章](https://zhuanlan.zhihu.com/p/37601161)，而介绍Transformer的文章可参考这两篇：一个是Jay Alammar可视化地介绍Transformer的博客文章[The Illustrated Transformer](https://link.zhihu.com/?target=https%3A//jalammar.github.io/illustrated-transformer/) ，非常容易理解整个机制，建议先从这篇看起；然后可以参考哈佛大学NLP研究组写的“[The Annotated Transformer.](https://link.zhihu.com/?target=http%3A//nlp.seas.harvard.edu/2018/04/03/attention.html) ”，代码原理双管齐下，讲得非常清楚。我相信上面两个文章足以让你了解Transformer了，所以这里不展开介绍。

​		其次，根据张俊林老师的判断，Transformer在未来会逐渐取代RNN成为主流的NLP工具，我认为是对的。RNN一直受困于其并行计算能力，这是因为它本身结构的序列型依赖导致的，尽管很多人在试图通过修正RNN结构来改进这一点，但我并不看好这种模式，因为给马车换轮胎还不如直接将它进行升级成汽车，这个道理很好懂，更何况如今这个汽车的雏形已经出现了，干嘛还非要执着于换轮胎这个事情上呢？再说CNN，CNN在NLP里一直没有形成主流，CNN的最大优点是易于做并行计算，所以速度快，但是在捕获NLP中的序列关系尤其是长距离特征方面存在着天然的缺陷，不是做不到而是做不好，目前也有很多改进模型，但是特别成功的不多。综合各方面情况，很明显Transformer同时具备并行性好喝适合捕获长距离特征，没有理由不在赛跑比赛中平跑不过RNN和CNN。

​		现在回到GPT。在第一阶段预训练好了之后，后面的下游任务如何使用呢，它和ELMO的使用方式大有不同。

![GPT下游1](https://i.loli.net/2019/12/23/4fLvVAnbTzyEGtW.png)

​		上图展示了GPT在第二阶段如何使用。首先，对于不同的下游任务来说，本来你可以**任意设计**自己的网络结构，现在不行了，你要向GPT的网络结构看齐，把任务的网络结构改造成和GPT一致的网络结构。然后，在做下游任务的时候，利用第一步预训练好的参数初始化GPT的网络结构，这样通过预训练学到的语言学知识就被引入到你手头的任务里来了，这是个非常好的事情。再次，你可以用手头的任务去训练这个网络，对网络参数进行Fine-tuning，使得这个网络更适合解决手头的问题。

​		这里引入了一个新问题：对于NLP各种花样的不同任务，怎么改造才能靠近GPT的网络结构呢？

![GPT改造下游任务](https://i.loli.net/2019/12/23/jDWKIofRUEBHl3w.png)

​		GPT论文中给了一个改造施工图，如上图所示：对于分类问题，不需要做出什么复杂变动，只需要加上一个起始符号和一个终结符号即可；对于句子判断问题，比如Entailment，两个句子中间再加个分隔符即可；对于文本相似性判断问题，把两个句子顺序颠倒下做出两个输入即可，这是为了告诉模型句子顺序不重要；对于多项选择问题，则多路输入，每一路将文章和答案选项拼接作为输入即可。从上图可看出，这种改造还是很方便的，不同任务只需要在输入部分施工即可。

![GPT效果](https://i.loli.net/2019/12/23/Lql13X2r9WZU5VF.png)

​		而效果方面，GPT在当时所取得的效果是非常惊艳的，在12个任务里，9个达到了最好的效果(SOTA)，有些任务性能提升非常明显。

​		那么在BERT出来之后，再次回看GPT，它主要存在两个缺点：1.采用的是单向语言模型，改成双向会更好；2.炒作能力喽（如果和BERT一样会炒作，GPT也是一个很有代表的技术作品）。

# BERT

![BERT](https://i.loli.net/2019/12/23/JSizYLm4gWZrsyM.png)

​		介绍了Word2Vec、ELMO以及GPT，终于到了蒂花之秀的秀---BERT。

​		Bert采用和GPT完全相同的两阶段模型，首先是语言模型预训练；其次是使用Fine-tuning模式解决下游任务。和GPT的最主要不同在于在预训练阶段采用了类似ELMO的双向语言模型，当然另外一点是语言模型的数据规模要比GPT大。所以这里BERT的预训练过程不必多讲。

![Bert下游应用](https://i.loli.net/2019/12/23/oJCst6bFw4ynjpr.png)

​		进入第二阶段，Fine-tuning阶段。这个阶段的做法与GPT一致。当然，它也面临着下游任务网络结构改造的问题，在改造任务方面Bert和GPT有些不同，下面将进行详细介绍。

​		在介绍Bert如何改造下游任务之前，先大致说下NLP的几类问题，说这个是为了强调Bert的普适性有多强。通常而言，绝大多数NLP问题可归入四类问题：

|              |             示例              |                         描述                         |
| :----------: | :---------------------------: | :--------------------------------------------------: |
|   序列标注   | 分词/POS Tag/NER/语义标注...  | 句子中每个单词要求模型根据上下文都要给出一个分类类别 |
|   分类任务   |     文本分类/情感计算...      |       不管文章有多长，总体给出一个分类类别即可       |
| 句子关系判断 | Entailment/QA/自然语言推理... | 给定两个句子，模型判断出两个句子是否具备某种语义关系 |
|  生成式任务  |     机器翻译/文本摘要...      |       输入文本内容后，需要自主生成另外一段文字       |

![BERT下游任务改造](https://i.loli.net/2019/12/23/TQNpL5ijV913FDy.png)

​		对于种类如此繁多且各具特点的下游NLP任务，Bert如何改造输入输出部分使得大部分NLP任务都可以使用Bert预训练好的模型参数呢？如上图所示，针对句子关系类任务，与GPT一样简单，加上一个起始符号和一个终结符号，句子之间加个分隔符即可。对于输出来说，把第一个起始符号对应的Transformer最后一层位置上面串接一个softmax分类层即可。对于分类问题，与GPT一样，只需要增加起始符号和终结符号，输出部分和句子关系类任务类似改造；对于序列标注任务，输入部分和单句分类一致，只需要针对输出部分Transformer最后一层每个单词对应位置的隐层特征进行分类即可。从这里可以看出，上面列出的NLP四大任务里面，除了生成类任务外，Bert其他都覆盖到了，而且改造起来很简单直观。尽管Bert论文没有提，但是稍微动动脑子就可以想到，其实对于机器翻译或者文本摘要、聊天机器人这种生成式任务，同样可以稍作改造即可引入Bert的预训练成果。只需要附着在Seq2Seq结构上，encoder部分是个深度Transformer结构，decoder部分也是个深度Transformer结构。根据任务选择不同的预训练数据初始化encoder和decoder即可。这是相当直观的一种改造方法，当然，也可以更简单一点，比如直接在单个Transformer结构上加装隐层产生输出也是可以的。不论如何，从这里可以看出，NLP四大类任务都可以比较方便地改造成Bert能够接受的方式。这其实是Bert的非常大的优点，这意味着它几乎可以做任何NLP的下游任务，具备普适性，这是很强的。

![Bert效果](https://i.loli.net/2019/12/23/f5aW82dQi3jyrvH.png)

​		Bert采用这种两阶段方式解决各种NLP任务效果如何呢？如上图所示，在11个各种类型的NLP任务中达到目前最好的效果，某些任务性能有极大的提升。

## 模型演进

![模型演进关系](https://i.loli.net/2019/12/23/QE4TyWzRYHlkuLO.png)

​		此处我们在梳理下上述模型之间的演进关系。从上图可见，Bert其实和ELMO及GPT存在千丝万缕的关系，比如我们把GPT预训练阶段换成双向语言模型，即可得到Bert；而如果我们把ELMO的特征抽取器换成Transformer，那么也能得到Bert。因此：Bert最关键的亮点，一点是特征抽取器采用Transformer，另一点是预训练的时候采用双向语言模型。

​		那么有一个问题：对于Transformer来说，怎么才能在这个结构上做双向语言模型任务呢？乍一看上去好像不太好搞。我觉得吧，其实有一种很直观的思路，怎么办？看看ELMO的网络结构图，只需要把两个LSTM替换成两个Transformer，一个负责正向，一个负责反向特征提取，其实应该就可以。当然这是我自己的改造，Bert没这么做。那么Bert是怎么做的呢？我们前面不是提过Word2Vec吗？我前面肯定不是漫无目的地提到它，提它是为了在这里引出那个CBOW训练方法，所谓写作时候埋伏笔的“草蛇灰线，伏脉千里”，大概就是这个意思吧？前面提到了CBOW方法，它的核心思想是：在做语言模型任务的时候，我把要预测的单词抠掉，然后根据它的上文Context-Before和下文Context-after去预测单词。其实Bert怎么做的？Bert就是这么做的。从这里可以看到方法间的继承关系。当然Bert作者没提Word2Vec及CBOW方法，这是我的判断，Bert作者说是受到完形填空任务的启发，这也很可能，但是我觉得他们要是没想到过CBOW估计是不太可能的。

​		从这里可以看出，在文章开始我说过Bert在模型方面其实没有太大创新，更像一个最近几年NLP重要技术的集大成者，原因在于此，当然我不确定你怎么看，是否认同这种看法，而且我也不关心你怎么看。其实Bert本身的效果好和普适性强才是最大的亮点。

## BERT的创新

![Bert构造双向语言模型](https://i.loli.net/2019/12/23/bewEYaVDqz6KCpW.png)

​		那么Bert本身在模型和方法角度有什么创新呢？就是论文中指出的Masked语言模型和Next Sentence Prediction。而Masked语言模型上面讲了，本质思想是CBOW，但是细节方面有改进。

![Masked LM](https://i.loli.net/2019/12/23/jZUiXAY9w7QcEPm.png)

​		Masked双向语言模型的做法如上图所示：随机选择语料中15%的单词，把它抠掉，也就是用[MASK]掩码代替原始单词，然后要求模型去正确预测被抠掉的单词。但是这里有个问题：训练过程大量看到[MASK]标记，但是真正后面用的时候是不会有这个标记的，这会引导模型认为输出是针对[MASK]这个标记的，但是实际使用又见不到这个标记，这自然会存在问题。为了避免这个问题，Bert改造了一下，15%的被上天选中要执行[MASK]替身这项光荣任务的单词中，只有80%真正地被替换成[MASK]标记，10%被狸猫换太子的随机替换成另外一个单词，剩余10%这个单词还待在原地不做改动。这就是Masked双向语言模型的具体做法。

![下句预测](https://i.loli.net/2019/12/23/maonpVGb1qSEkI2.png)

​		至于说“Next Sentence Prediction”，指的是做语言模型预训练的时候，分两种情况选择两个句子，一种是选择预料中真正顺序相连的两个句子；另外一种是第二个句子从语料库中抛色子，随机选择一个拼接到第一个句子后面。我们要求模型除了做上述的Masked语言模型任务外，附带再做个句子关系预测，判断第二个句子是不是真的是第一个句子的后续句子。之所以这么做，是考虑到很多NLP任务是句子关系判断任务，单词预测粒度的训练到不了句子关系这个层级，增加这个任务有助于下游句子关系判断任务。所以可以看到，Bert的预训练是个多任务过程，这也是Bert的一个创新。

## 实例介绍

![实例](https://i.loli.net/2019/12/23/eMCLahGrbDSx7nP.png)

​		上面这个图给出了一个之前利用微博数据和开源Bert做预训练时随机抽出的一个中文训练实例，从中可以体会下上面介绍的Masked语言模型和下句预测任务。训练数据就长这样子。

![Bert输入处理](https://i.loli.net/2019/12/23/9SRTvGEPbJB38gM.png)

​		那么训练实例中的各个输入部分都代表什么呢？它的输入也是很有特色，它的输入部分是个线性序列，两个句子通过分隔符[SEP]分割，最前面和最后增加两个标识符号。每个单词有三个embedding：位置embedding、单词embedding、句子embedding。其中针对位置embedding，是因为NLP中单词顺序是很重要的特征，需要在这里对位置信息进行编码；而单词embedding就是我们之前一直提到的word embedding；第三个句子embedding，因为前面提到训练数据都是由两个句子构成的，那么每个句子有个句子整体的embedding项对应给各个单词。把单词对应的三个embedding叠加，就形成了Bert的输入。

![Bert预训练的输出处理](https://i.loli.net/2019/12/23/xL4INlHFirRVvAY.png)

​		至于Bert在预训练的输出部分如何组织，可以参考上图的注释。

![Bert有效因子分析](https://i.loli.net/2019/12/23/IlM6vgpr2DebFOo.png)

​		那么Bert效果这么好，到底是什么因素在起作用呢？如上图所示，对比实验可以证明，跟GPT相比，双向语言模型起到了最主要的作用，对于那些需要看到下文的任务来说尤其如此。而预测下个句子来说对整体性能影响不算太大，跟具体任务关联度比较高。

# 总结

​		Bert是NLP领域中里程碑式的工作，主要表现在以下几点：

1.Bert并未有重大模型创新，而是近几年NLP领域重大进展的集大成者。

2.充分利用大量无监督NLP数据，将语言学知识隐含地引入特定任务中；

3.效果太好，将影响未来NLP的研究和应用模式：

​	3.1 Transformer逐步取代RNN和CNN；

​	3.2 两阶段模型：超大规模预训练+具体任务FineTuning(两阶段模型结构相近)或者超大规模预训练+具体任务特征补充（两阶段模型结构可以不同）

从模型或者方法角度看，Bert借鉴了ELMO，GPT及CBOW，主要提出了Masked 语言模型及Next Sentence Prediction，但是这里Next Sentence Prediction基本不影响大局，而Masked LM明显借鉴了CBOW的思想。所以说Bert的模型没什么大的创新，更像最近几年NLP重要进展的集大成者。Bert最大的亮点在于效果好及普适性强，几乎所有NLP任务都可以套用Bert这种两阶段解决思路，而且效果应该会有明显提升。可以预见的是，未来一段时间在NLP应用领域，Transformer将占据主导地位，而且这种两阶段预训练方法也会主导各种应用。

​		另外，针对预训练过程，其本质上是通过设计好一个网络结构来做语言建模任务，然后把大量甚至是无穷尽的无标注的自然语言文本利用起来，预训练任务把大量语言学知识抽取出来编码到网络结构中，当手头任务带有标注信息的数据有限时，这些先验的语言学特征当然会对手头任务有极大的特征补充作用，因为当数据有限的时候，很多语言学现象是覆盖不到的，泛化能力就弱，集成尽量通用的语言学知识自然会加强模型的泛化能力。如何引入先验的语言学知识其实一直是NLP尤其是深度学习场景下的NLP的主要目标之一，不过一直没有太好的解决办法，而ELMO/GPT/Bert的这种两阶段模式看起来无疑是解决这个问题自然又简洁的方法，这也是这些方法的主要价值所在。

​		对于当前NLP的发展方向，我个人觉得有两点非常重要，一个是需要更强的特征抽取器，目前看Transformer会逐渐担当大任，但是肯定还是不够强的，需要发展更强的特征抽取器；第二个就是如何优雅地引入大量无监督数据中包含的语言学知识，注意我这里强调地是优雅，而不是引入，此前相当多的工作试图做各种语言学知识的嫁接或者引入，但是很多方法看着让人牙疼，就是我说的不优雅。目前看预训练这种两阶段方法还是很有效的，也非常简洁，当然后面肯定还会有更好的模型出现。
